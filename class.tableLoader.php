<?php namespace inc\csvLoader;/** * Класс для загрузки и обновления таблицы из файла csv. * * Клас создан с использованием функции из статьи : * http://www.softwareprojects.com/resources/programming/t-how-to-use-mysql-fast-load-data-for-updates-1753.html * * Клас использует файл csv для обновления данных таблицы * данные из файла вставляются в таблицу, если они в ней отсутствовали(проверка id). * а существующие в таблице данные обновляются, согласно файлу csv, если * в файле csv поля не пустые и не NULL * * Например:  * таблица имеет вид : id | name | address *						1 |  Joe | Wall st. 6 *						2 | Mary | Some st. 4 *						5 | Kate | Another st. 1 *	 *поле id - int AUTO INCREMENT *           * Файл имеет вид :    ИД | Имя | Адрес *						1 | Joe | newWall st. 3   //изменен адрес *						  | Tim | SomeTwo st. 8   // новая запись, в БД ее еще нет *						2 | Mary3|                // поменяли имя, а адрес удалили * * В результате мы получим данные в таблице: id | name | address *   										 1 | Joe   | newWall st. 3  // адрес изменился *											 2 | Mary3 | Some st. 4    // изменилось имя, а адрес остался, хоть в файле csv пустое поле *											 5 | Kate | Another st. 1  // запись без изменений *											 6 | Tim  | SomeTwo st. 8  // новая запись добавилась в таблицу *  * 			ПОРЯДОК ДЕЙСТВИЙ * 1.Создается временная таблица, в нее заносятся все данные из файла csv * * 2.Записи, которые сущестуют в таблице БД отмечаются временной таблице, *   проставлением в одно из ее полей id из сущетвующей в БД таблицы.  * *  Временная таблица будет меть вид : 	id| name | address		| id_existing *										1 | Joe | newWall st. 3 | 1 *										2 | Mary | Some st. 4   | 2 *										  | Tim | SomeTwo st. 8 | 0 * *  Запись с name==Tim не существует в БД, а есть только в csv файле. * * 3.Записи которые новые, т.е. имеют в поле id_existing - 0, *   Заносятся в новый csv файл и грузятся в сущ.таблицу. * * Класс использует загрузку в БД mySQL используя LOAD DATA LOCAL INFILE * Это позволяет загружать большие объемы данных. * * 4.Остальные записи, которые имеют поле id_existing>0 ,т.е. уже существуют в таблице БД, *   используются для обновления таблицы БД запросом UPDATE. * * * @author Author <example@some.com> * @copyright 2015 Rencredit */class tableLoader{	/**     * Связь с БД.     *     * @var resource     */    public $DBLink;	/**     *Полный адрес файла cvs с данными для загрузки     *     * @var string     */    public $inputfile;    /**     * Разделитель в файле csv     *     * @var string     */    public $csv_csv_delimiter;        /**     * Имя таблицы в БД MySQL     *     * @var string     */    public $tablename;    /**     * Поле таблицы по которому будет происходить сравнение,     * т.е. id, по котрому класс определяет есть в таблице запись или нет     *     * @var string     */    public $tablename_recordid_keyname;    /**     * Имя дирректории для сохранения временных файлов     *     * @var string     */    public $temp_dir;    /**     * Массив для создания временной таблицы     * поле id_external создается во временной таблице как ключ     * Вида :     * 		array(	 *				array("name" => "name", "type" => "varchar", "length" => "50"),	 *				array("name" => "address", "type" => "varchar", "length" => "300"),	 *				);     *      * @var array     */    public $arr_inputfields;    /**     * Массив соответствий (Имя поля файла CSV -> Имя поля _!_временной_!_ таблицы)     * например array('id_external'=>'ИД','name'=>'Имя','address'=>'Адрес')     *     * @var array     */    public $csv_temp_relations;    /**     * Массив полей существующей таблицы и их связь с временной таблицей,для аптейтов.     * Вида :array(	 * 				array("name" => "имя поля табл.БД","matchto" =>"имя поля врем. табл."),	 * 				array("name" => "name","matchto" =>"name"),	 * 				array("name" => "address","matchto" =>"address"),     *      *     * @var array     */    public $arr_existingfields;     /**     * Действия с временной таблицей, которые надо выполнить, сразу после      * занесения в нее данных из файла CVS. ОПЦИОНАЛЬНО     *      * @var string     */    public $sql_synthasize;    /**     * Кол-во записей, которые были внесены в таблицу     *      * @var int     */    public $countInsertedRows;       /**     * Кол-во записей, которые были обновлены в таблице     *      * @var int     */    public $countUpdatedRows;    /**     * Debug mode/вывод ошибок     *      * @var bool     */    public $flag_debug;    /**     * Не переписывать пустыми значениями существующие поля.     *      * @var bool     */    public $noNULLRewrite;    /**     * Части строк запросов.     *      * @var array     */    public $queryStrings;       /**     * Конструктор      * Устанавливает значения обязательных полей     * 		$inputfile	 * 		$tablename	 * 		$tablename_recordid_keyname	 * 		$temp_dir	 * 		$csv_temp_relations	 * 		$arr_inputfields	 * 		$arr_existingfields	 *     * @param resource $DBLink 						Связь с БД     * @param string $inputfile 					Адрес файла cvs для загрузки     * @param string $tablename 					Имя таблицы в БД     * @param string $tablename_recordid_keyname 	Поле таблицы по которому будет происходить сравнение     * @param string $temp_dir 						Имя дирректории для сохранения временных файлов     * @param array $csv_temp_relations 				Массив соответствий (Имя поля файла CSV -> Имя поля таблицы)		     * @param array $arr_inputfields 				Массив для создания временной таблицы		     * @param array $arr_existingfields 			Массив полей существующей таблицы и их связь с временной таблицей,для аптейтов.			     * @return void     */    public function __construct($DBLink,    							$inputfile,    							$csv_csv_delimiter,								$tablename,								$tablename_recordid_keyname,								$temp_dir,								array $csv_temp_relations,								array $arr_inputfields,								array $arr_existingfields)    {    	if(!$DBLink){    		throw new \Exception('Нет связи с БД');return;    	}    	$this->DBLink = $DBLink;    	if( ! \file_exists($inputfile) ){    		throw new \Exception("Файл с адресом {$inputfile} не найден");return;    	}		$this->inputfile = $inputfile;         $table_exists = \mysql_query("SHOW TABLES LIKE '".$tablename."'");        $table_exists = \mysql_num_rows($table_exists)==1;		if( ! $table_exists ){			throw new \Exception("Таблица '{$tablename}' не существует в БД");return;		}		$this->csv_csv_delimiter = $csv_csv_delimiter;	    	$this->tablename = $tablename;		$this->tablename_recordid_keyname = $tablename_recordid_keyname;		if(! is_dir($temp_dir) ){			throw new \Exception("Директория {$temp_dir} не найдена");return;		}		$this->temp_dir = $temp_dir;		$this->csv_temp_relations = $csv_temp_relations;				$this->arr_inputfields = $arr_inputfields;		$this->arr_existingfields = $arr_existingfields;		$this->flag_debug = false;		$this->queryStrings = $this->GetQueryStrings($this->arr_existingfields,													 $this->tablename,													 $this->tablename_recordid_keyname);		$this->noNULLRewrite=true;		$this->countUpdatedRows=0;		$this->countInsertedRows=0;    }    /**     * Перезаписывать поле таблицы пустым значением, если в csv в поле пусто.   	 * @return void     */    public function setNullWrite(){    	$this->noNULLRewrite = false;    }     /**     * В режиме дебага   	 * @return void     */    public function setDebugMode(){    	 $this->flag_debug=true;    }       /**     * Строки дополнительных запросов UPDATE к временной таблице, после ее создания     * Сктока вида : <поле времтаблицы1>='val' WHERE; <поле времтаблицы2>='val' WHERE;   	 * @param string   	 * @return void     */    public function setSql_synthasize($sql_synthasize){    	$this->sql_synthasize = $sql_synthasize;    }    /**     * Загружает данные в базу данных, и производит     * обновление существующих данных   	 * @return array     */    public function load(){    	# создаем временную таблицу    	try{    		$flag = $this->createTemporaryTable($this->arr_inputfields);    	}catch(\Exception $e){    		if($this->flag_debug) print($e->getMessage());    	}    	if(!$flag) {    		if($this->flag_debug) die('Временная таблица не была создана.');    		else die();    	}    	# заполняем таблицу данными    	try{    		$flag = $this->LoadDataInTemporaryTable( $this->csv_temp_relations,    												$this->inputfile,    												$this->csv_csv_delimiter,     										  		$this->temp_dir);    		    	}catch(\Exception $e){    		if($this->flag_debug) print($e->getMessage());    	}    	if(!$flag) {    		if($this->flag_debug) die('В Временную таблицу не внесены данные.');    		else die();    	}    	# дополнительные строки в UPDATE запрос    	$sql_sub_str = '';    	# Если нужно, чтобы вносимые пустые данные полей не перезаписывали существующие заполненные.    	if($this->noNULLRewrite){    		$sql_str = '';			# условие : NULL поля не обновляем!			foreach ($this->arr_existingfields as $field) {				$sql_str .= "temporary_temp_table.{$field['matchto']}=IFNULL(temporary_temp_table.{$field['matchto']},{$this->tablename}.{$field['name']}),";			}			$sql_str = substr($sql_str, 0, strlen($sql_str)-1);			$sql_str.=" WHERE temporary_temp_table.id_external={$this->tablename}.{$this->tablename_recordid_keyname}";			$sql_str.=';';			# условие : пустые поля не обновляем!			foreach ($this->arr_existingfields as $field) {				$sql_str .= "temporary_temp_table.{$field['matchto']}=IF(temporary_temp_table.{$field['matchto']}>'',temporary_temp_table.{$field['matchto']},{$this->tablename}.{$field['name']}),";			}			$sql_str = substr($sql_str, 0, strlen($sql_str)-1);			$sql_str.=" WHERE temporary_temp_table.id_external={$this->tablename}.{$this->tablename_recordid_keyname}";			$this->addUpdate($sql_str,$this->tablename);    	}    	# Если нужно, произвести еще дополнительный UPDATE временной таблицы, например переписать некоторые поля.        # опцонально    	if($this->sql_synthasize){    		$this->addUpdate($this->sql_synthasize);    	}    	    	# обновим таблицу, найдем соответсвия в сущ.таблице, определим какие данные     	# требуется обновить, а какие просто внести. проставив поле id_existing    	try{    		$flag = $this->UpdateTemporaryTable($this->tablename,    											$this->tablename_recordid_keyname);    		    	}catch(\Exception $e){    		if($this->flag_debug) print($e->getMessage());    	}    	if(!$flag) {    		if($this->flag_debug) die('В Временную таблицу не внесены связанные id.');    		else die();    	}    	# все записи из временной таблици, у которых нет связанных записей из    	# существующей таблици - пишем в файл и затем вносим в сущ.таблицу из файла.    	try{    		$flag = $this->InsertNewRows($this->tablename,    									$this->queryStrings['fields_values'],    									$this->temp_dir);    		    	}catch(\Exception $e){    		if($this->flag_debug) print($e->getMessage());    	}    	if(!$flag) {    		if($this->flag_debug) die('Ошибка при внесении в таблицу новых записей.');    		else die();    	}    	# обновляем сущесвующие записи.    	try{    		$flag = $this->UpdateTable($this->tablename,    									$this->tablename_recordid_keyname,    									$this->queryStrings['fields_both']);    		    	}catch(\Exception $e){    		if($this->flag_debug) print($e->getMessage());    	}    	if(!$flag) {    		if($this->flag_debug) die('Ошибка при обновлении таблицы в БД.');    		else die();    	}    	# возвращаем массив, сколько вставили, сколько обновили    	return array('countInsertedRows'=>$this->countInsertedRows,'countUpdatedRows'=>$this->countUpdatedRows);    }    /**     *      * Создает временную таблицу в Базу Данных     *      * @param array $arr_inputfields массив для создания временной таблицы     * @return bool     */     private function createTemporaryTable($arr_inputfields){     	mysql_query("DROP TABLE temporary_temp_table");     	$sql_createtable = "CREATE /*TEMPORARY*/ TABLE temporary_temp_table (id_external char(50) default '' not null,";		# c указанными полями 		foreach ($arr_inputfields as $field)		{			$sql_createtable .= $field['name'];			if (empty($field['type']))			{			  $sql_createtable .= " char(";			  if (!empty($field['length']))			  {			    $sql_createtable .= $field['length'];			  }			  else			  {			    $sql_createtable .= "50";			  }			  $sql_createtable .= ") default '' not null,";			}			else        			{			  $sql_createtable .= " ".$field['type'];			  if (!empty($field['length']))			  {			    $sql_createtable .= '('.$field['length'].')';			  }			  $sql_createtable .= " ,";			}  		}		$sql_createtable .= "id_existing int default 0 not null,";		// поле id_existing будет хранить информацию о существовании записи с таким id в сущ.таблице		$sql_createtable .= "index (id_existing))"; 		# создаем таблицу		mysql_query($sql_createtable);		if( $err=mysql_error() ) throw new \Exception('Ошибка создания временной таблицы'.$err);		return true;      }    /**     *      * Заполняет временную таблицу данными из файла csv     *      * @param array $csv_temp_relations     * @return bool     */     private function LoadDataInTemporaryTable( $csv_temp_relations,     											$inputfile,     											$csv_delimiter,     											$temp_dir												){	    /*формируем колонки, которые будем вставлять */	  	$ACOLS=array_flip($csv_temp_relations);	    $sqlcols = array();	    # берем содаржимое файла.	    $data = file_get_contents($inputfile);    	    $data = str_replace('"','',$data);   		/*кодировку меняем , там она CP1251 для excel*/		$data = iconv('CP1251','UTF-8',$data);			# имя cache файла		$cache_inputfile = $temp_dir.sha1(time()).'.csv';		@unlink($cache_inputfile);				# перезаписываем в UTF8 в новый файл		$handle = fopen($cache_inputfile, "w");		fwrite($handle,$data);		fclose($handle);			  	# читаем из файла заголовки столбцов	    $f = fopen($cache_inputfile,'r');		$row1 = trim(fgets($f));			fclose($f);		$arow = explode($csv_delimiter,$row1);				$row0 = array();		$matches =0;		# тут проверяем заголовки в файле, если такой заголовок отсутствует в $csv_db_relations,		# то не будет внесен в врем.таблицу (@dummy)		for ($i=0; $i<count($arow); $i++) {			$row0[] = $i;			if($arow[$i]=='') continue;				if( isset( $ACOLS[$arow[$i]] ) ) $matches++;				$sqlcols [] = isset( $ACOLS[$arow[$i]] ) ? $ACOLS[$arow[$i]] : '@dummy';		}		if(! $matches){			throw new \Exception('В файле csv имена колонок имеют неверные имена.'.$err);			return;		}	  	# Импортируем все записи в временную таблицу из файла прямой загрузкой.	  		  	$query="LOAD DATA LOCAL INFILE '$cache_inputfile' ignore INTO TABLE temporary_temp_table FIELDS TERMINATED BY '{$csv_delimiter}' "	  	." OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\r\\n' "  		."  IGNORE 1 LINES(".implode(',',$sqlcols).")"."";	  	mysql_query($query);	  	# проверяем ошибки	  	if( $err=mysql_error() ){ throw new \Exception('Ошибка внесения данных в временную таблицу'.$err);return;}	  	# удалим временной файл csv.	  	unlink($cache_inputfile);	  	return true;     }    /**     *      * Проставляет в временную таблицу в поле id_existing id-ключ из сущестующей таблицы     *      * @param string $tablename  Имя таблицы      * @param string $tablename_recordid_keyname  Поле существующей таблицы,для связи с временной.     *												Значение этого поля ставится в id_existing врем.табл.     * @return bool     */     private function UpdateTemporaryTable($tablename,$tablename_recordid_keyname){     	     	$query="UPDATE temporary_temp_table,$tablename SET temporary_temp_table.id_existing=".				"$tablename.$tablename_recordid_keyname WHERE temporary_temp_table.id_external=$tablename.$tablename_recordid_keyname";		mysql_query($query);		if( $err=mysql_error() ){ throw new \Exception('Ошибка обновления временной таблицы'.$err);return;}		return true;     }     /**     *      * Формируем строки для запросов UPDATE      *      * @param array $arr_existingfields      * @param string $arr_existingfields      * @param string $arr_existingfields      * @return array     */     private function GetQueryStrings(	array $arr_existingfields,     									$tablename,     									$tablename_recordid_keyname){     	$sql_fields_values = "";		$sql_fields_names = "$tablename_recordid_keyname,";		$sql_fields_both = "";		foreach ($arr_existingfields as $field)		{			$sql_fields_names .= $field['name'].",";			$sql_fields_both .= "$tablename.".$field['name']."=";			if (isset($field['value']))			{			  $sql_fields_values .= "'".$field['value']."',";			  $sql_fields_both .= "'".$field['value']."',";			}			else			{			  $sql_fields_values .= $field['matchto'].",";			  $sql_fields_both .= "temporary_temp_table.".$field['matchto'].",";			}		}		$sql_fields_both = substr($sql_fields_both, 0, strlen($sql_fields_both)-1);		$sql_fields_names = substr($sql_fields_names, 0, strlen($sql_fields_names)-1);		$sql_fields_values = substr($sql_fields_values, 0, strlen($sql_fields_values)-1);		return array(	'fields_both'=>$sql_fields_both,						'fields_names'=>$sql_fields_names,						'fields_values'=>$sql_fields_values);     }    /**     * доп. UPDATE совпадающих данных в врем.таблице.     * @param string $sql_string     * @param string $tablename     */    private function addUpdate($sql_string,$tablename=false){        if($tablename) $tablename =','.$tablename;        else $tablename='';        $sql = strtok($sql_string, ";");        while (!empty($sql))        {           if(!strlen($sql)) continue;          $query="UPDATE temporary_temp_table {$tablename} SET $sql";		  mysql_query($query);		  if( $err=mysql_error() ){ throw new \Exception('Ошибка обновления врем.таблицы'.$err);return;}		  $sql = strtok(";");		}    }    /**     *      * Вносит новые данные в сущестующую таблицу     *      * @param string $tablename  Имя таблицы     * @param string $sql_fields_values  поля врем. таблицы,которые выбираем запросом                  	     * @param string $temp_dir  cache дирректория                  	     * @return bool     */     private function InsertNewRows($tablename,$sql_fields_values,$temp_dir){        $cache_file = $temp_dir.sha1(time()).'.csv';        @unlink($cache_file);        $query="select $sql_fields_values INTO OUTFILE \"$cache_file\" ".        " FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '' LINES TERMINATED BY '\n' ".        " FROM temporary_temp_table where id_existing=0";        mysql_query($query);				if( $err=mysql_error() ){ throw new \Exception('Ошибка записи данных в файл'.$err);return;}		$res = mysql_query("SELECT *  FROM temporary_temp_table where id_existing=0");		$num=0;		if($res)while($row = mysql_fetch_assoc($res)) {			$rows[]=$row;			$num++;		}		if($num){                        foreach($this->arr_existingfields as $field){                $fields[]=$field['name'];            }            $query = "LOAD DATA LOCAL INFILE '$cache_file' INTO TABLE {$tablename} FIELDS TERMINATED BY ';' ".            " IGNORE 0 LINES(".implode(',',$fields).")";	  		mysql_query($query);			if( $err=mysql_error() ){ throw new \Exception('Ошибка вставки новых данных в таблицу'.$err);return;}		}		unlink($cache_file);		$this->countInsertedRows = $num;		return true;     }     /**     *      * Вносит новые данные в сущестующую таблицу     *      * @param string $tablename  Имя таблицы     * @param string $tablename_recordid_keyname  поля врем. таблицы,которые выбираем запросом                  	     * @param string $sql_fields_both  часть запроса                	     * @return bool     */     private function UpdateTable($tablename,$tablename_recordid_keyname,$sql_fields_both){     	$query="UPDATE $tablename,temporary_temp_table SET $sql_fields_both where $tablename.$tablename_recordid_keyname".  		"=temporary_temp_table.id_external and id_existing!=0";  		mysql_query($query);			if( $err=mysql_error() ){ throw new \Exception('Ошибка обновления данных в таблице в БД'.$err);return;}		$this->countUpdatedRows = mysql_affected_rows();		return true;     }}